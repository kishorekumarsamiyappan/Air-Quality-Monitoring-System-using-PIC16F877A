#include <16F877A.h>
#device ADC=10   // 10-bit ADC
#FUSES NOWDT, PUT, NOBROWNOUT, NOLVP, HS
#use delay(crystal=20MHz)

// ---- Hardware connections ----
#bit SERVO      = 0x08.0  // RD0 - Servo (window)
#bit BUTTON     = 0x08.3  // Manual servo switch
#bit FAN        = 0x08.2
#bit SWITCH1    = 0x08.1  // Manual fan
#bit LED_GREEN  = 0x08.4
#bit LED_YELLOW = 0x08.5
#bit LED_RED    = 0x08.6
#bit BUZZER     = 0x08.7

// ---- LCD connections ----
#define LCD_ENABLE_PIN  PIN_B2
#define LCD_RS_PIN      PIN_B0
#define LCD_RW_PIN      PIN_B1
#define LCD_DATA4       PIN_B4
#define LCD_DATA5       PIN_B5
#define LCD_DATA6       PIN_B6
#define LCD_DATA7       PIN_B7
#include <lcd.c>

// ---- DHT11 ----
#define DHT11_PIN PIN_C0

short dht11_read_data(unsigned int8 *data);
void dht11_start();
int1 dht11_check_response();
unsigned int8 dht11_read_byte();

// ---- Servo function ----
void servo_set_angle(int angle) {
   int16 pulse_width;
   pulse_width = 1000 + ((int32)angle * 1000) / 180;
   SERVO = 1;
   delay_us(pulse_width);
   SERVO = 0;
   delay_us(20000 - pulse_width);
}

// ---- Main program ----
void main() {
   set_tris_d(0b00001010); // RD1 & RD3 input, others output
   setup_adc_ports(ALL_ANALOG);
   setup_adc(ADC_CLOCK_INTERNAL);
   lcd_init();

   int servo_angle = 0;
   int16 mq135, pm25;
   float mq_voltage, mq_ppm;
   unsigned int8 dht_data[5];
   unsigned int8 RH_int, RH_dec, T_int, T_dec;
   int fan_status = 0, air_status = 0, buzzer_status = 0;

   // Initial states
   FAN = 0; SERVO = 0; servo_angle = 0;
   BUZZER = 0; LED_GREEN = 0; LED_YELLOW = 0; LED_RED = 0;

   // Welcome screen
   lcd_putc("\fMICRO PROJECT");
   lcd_gotoxy(1,2);
   lcd_putc("   EIOT SYSTEM  ");
   delay_ms(1000);
   lcd_putc("\fAir Quality");
   lcd_gotoxy(1,2);
   lcd_putc("   Monitor    ");
   delay_ms(1000);

   while(TRUE) {
      // ---- Manual servo control ----
      if(BUTTON) servo_angle = 90;
      else servo_angle = 0;

      // ---- Read MQ135 (AN0) ----
      set_adc_channel(0); delay_us(20);
      mq135 = read_adc();
      mq_voltage = (mq135 * 5.0)/1023.0;
      mq_ppm = mq_voltage * 200.0; // Approx PPM

      // ---- Read PM2.5 (AN1) ----
      set_adc_channel(1); delay_us(20);
      pm25 = read_adc();

      // ---- Read DHT11 ----
      if(dht11_read_data(dht_data)) {
         RH_int = dht_data[0];
         RH_dec = dht_data[1];
         T_int  = dht_data[2];
         T_dec  = dht_data[3];
      } else {
         RH_int=RH_dec=T_int=T_dec=0;
      }

      // ---- Air quality logic ----
      int temp_status=0;
      if(T_int <= 30) temp_status=0;
      else if(T_int <= 40) temp_status=1;
      else temp_status=2;

      int hum_status=0;
      if(RH_int <= 50) hum_status=0;
      else if(RH_int <= 70) hum_status=1;
      else hum_status=2;

      int mq_status=0;
      if(mq_ppm <= 200) mq_status=0;
      else if(mq_ppm <= 500) mq_status=1;
      else mq_status=2;

      int pm_status=0;
      if(pm25 <= 60) pm_status=0;
      else if(pm25 <= 100) pm_status=1;
      else pm_status=2;

      // Final air status = worst among sensors
      air_status = temp_status;
      if(hum_status > air_status) air_status = hum_status;
      if(mq_status > air_status) air_status = mq_status;
      if(pm_status > air_status) air_status = pm_status;

      // ---- Device control ----
      if(air_status==0) { // GOOD
         LED_GREEN=1; LED_YELLOW=0; LED_RED=0;
         FAN=0; fan_status=0; BUZZER=0; buzzer_status=0;
         servo_angle=0;
      } else if(air_status==1) { // MEDIUM
         LED_GREEN=0; LED_YELLOW=1; LED_RED=0;
         FAN=0; fan_status=0; BUZZER=0; buzzer_status=0;
         servo_angle=0;
      } else { // BAD
         LED_GREEN=0; LED_YELLOW=0; LED_RED=1;
         FAN=1; fan_status=1; BUZZER=1; buzzer_status=1;
         servo_angle=90;
      }

      // Manual fan override
      if(SWITCH1) { FAN=1; fan_status=1; }

      // ---- LCD Display ----
      lcd_putc("\fTEMP: "); 
      printf(lcd_putc,"%u.%uC",T_int,T_dec);
      lcd_gotoxy(1,2);
      printf(lcd_putc,"HUM: %u.%u%%",RH_int,RH_dec);
      delay_ms(500);

      lcd_putc("\fMQ135: ");
      printf(lcd_putc,"%.1fppm",mq_ppm);
      lcd_gotoxy(1,2);
      printf(lcd_putc,"PM2.5: %lu",pm25);
      delay_ms(500);

      lcd_putc("\fAir Status:");
      lcd_gotoxy(1,2);
      if(air_status==0) lcd_putc("GOOD");
      else if(air_status==1) lcd_putc("MEDIUM");
      else lcd_putc("BAD!!");
      delay_ms(500);

      lcd_putc("\fFAN: ");
      if(fan_status) lcd_putc("ON"); else lcd_putc("OFF");
      lcd_gotoxy(1,2);
      if(servo_angle==90) lcd_putc("WINDOW OPEN");
      else lcd_putc("WINDOW CLOSED");
      delay_ms(500);

      // Servo movement
      for(int i=0;i<30;i++) servo_set_angle(servo_angle);
   }
}

// ---- DHT11 Functions ----
short dht11_read_data(unsigned int8 *data) {
   unsigned int8 i;
   dht11_start();
   if(!dht11_check_response()) return 0;
   for(i=0;i<5;i++) data[i]=dht11_read_byte();
   if(data[4]!=((data[0]+data[1]+data[2]+data[3]) & 0xFF)) return 0;
   return 1;
}

void dht11_start() {
   output_drive(DHT11_PIN);
   output_low(DHT11_PIN);
   delay_ms(20);
   output_high(DHT11_PIN);
   delay_us(30);
   set_tris_c(0x01); // input
}

int1 dht11_check_response() {
   delay_us(40);
   if(!input(DHT11_PIN)) {
      delay_us(80);
      if(input(DHT11_PIN)) {
         delay_us(40);
         return 1;
      }
   }
   return 0;
}

unsigned int8 dht11_read_byte() {
   unsigned int8 i, data=0;
   for(i=0;i<8;i++) {
      while(!input(DHT11_PIN));
      delay_us(30);
      if(input(DHT11_PIN)) data=(data<<1)|1;
      else data=(data<<1);
      while(input(DHT11_PIN));
   }
   return data;
}
