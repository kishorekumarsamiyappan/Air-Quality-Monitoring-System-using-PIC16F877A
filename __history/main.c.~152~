#include <16F877A.h>
#device ADC=10   // 10-bit ADC
#FUSES NOWDT, PUT, NOBROWNOUT, NOLVP, HS   // HS for 20 MHz crystal
#use delay(crystal=20MHz)

// ---- Hardware connections ----
#bit SERVO   = 0x08.0   // RD0 - Servo
#bit BUTTON  = 0x08.3   // RD3 - Manual Servo switch
#bit FAN     = 0x08.2   // RD2 - Fan
#bit SWITCH1 = 0x08.1   // RD1 - Manual Fan switch
#bit LED_GREEN  = 0x08.4   // RD4
#bit LED_YELLOW = 0x08.5   // RD5
#bit LED_RED    = 0x08.6   // RD6
#bit BUZZER     = 0x08.7   // RD7

// ---- LCD connections ----
#define LCD_ENABLE_PIN  PIN_B2
#define LCD_RS_PIN      PIN_B0
#define LCD_RW_PIN      PIN_B1
#define LCD_DATA4       PIN_B4
#define LCD_DATA5       PIN_B5
#define LCD_DATA6       PIN_B6
#define LCD_DATA7       PIN_B7
#include <lcd.c>

// ---- DHT11 Pin ----
#define DHT11_PIN PIN_C0   // Now DHT11 connected to RC0

// ---- DHT11 Function Prototypes ----
short dht11_read_data(unsigned int8 *data);
void dht11_start();
int1 dht11_check_response();
unsigned int8 dht11_read_byte();

// ---- Servo function (improved PWM) ----
void servo_set_angle(int angle) {
   int16 pulse_width;
   // More accurate pulse width calculation for standard servo (500-2500us)
   pulse_width = 500 + ((int32)angle * 2000) / 180;
   
   if(pulse_width < 500) pulse_width = 500;
   if(pulse_width > 2500) pulse_width = 2500;
   
   SERVO = 1;
   delay_us(pulse_width);
   SERVO = 0;
   delay_us(20000 - pulse_width);  // 20 ms period (50Hz)
}

// ---- Main program ----
void main() {
   set_tris_d(0b00001010);   // RD1 & RD3 inputs (manual switches), others outputs
   set_tris_c(0x01);         // RC0 as input for DHT11, others as needed
   
   setup_adc_ports(ALL_ANALOG);
   setup_adc(ADC_CLOCK_INTERNAL);

   lcd_init();

   int servo_angle = 0;   // default closed
   int16 mq135, pm25;
   float mq_voltage, mq_ppm;
   unsigned int8 dht_data[5];
   unsigned int8 RH_int, RH_dec, T_int, T_dec;
   int fan_status = 0;
   int air_status = 0;
   int buzzer_status = 0;

   // Initial device states
   FAN = 0; fan_status = 0;
   SERVO = 0; servo_angle = 0;
   BUZZER = 0; buzzer_status = 0;
   LED_GREEN = 0;
   LED_YELLOW = 0;
   LED_RED = 0;

   // ---- Welcome screens ----
   lcd_putc("\f MICRO  PROJECT  ");
   lcd_gotoxy(1,2);
   lcd_putc("      EIOT      ");
   delay_ms(2000);

   lcd_putc("\f  Air  Quality  ");
   lcd_gotoxy(1,2);
   lcd_putc(" Monitor System ");
   delay_ms(2000);

   while(TRUE) {
      // ---- Servo manual switch control (active LOW) ----
      if(!BUTTON) 
         servo_angle = 90; // pressed -> 90
      else 
         servo_angle = 0;  // released -> 0

      // ---- Read MQ135 sensor ----
      set_adc_channel(0); 
      delay_ms(10);    // Longer delay for ADC stabilization
      mq135 = read_adc();
      mq_voltage = (mq135 * 5.0) / 1023.0;
      mq_ppm = mq_voltage * 200.0;

      // ---- Read PM2.5 sensor ----
      set_adc_channel(1); 
      delay_ms(10);
      pm25 = read_adc();

      // ---- Read DHT11 ----
      if(dht11_read_data(dht_data)) {
         RH_int = dht_data[0];
         RH_dec = dht_data[1];
         T_int  = dht_data[2];
         T_dec  = dht_data[3];
      } else {
         // Use previous values if read fails
         // RH_int=RH_dec=T_int=T_dec=0; // Don't reset to zero, keep previous
      }

      // ---- Decision logic (improved thresholds) ----
      if(mq135 < 300 && pm25 < 300 && T_int < 30) {
         air_status = 0; // GOOD
      } 
      else if(mq135 < 700 && pm25 < 700 && T_int < 40) {
         air_status = 1; // MODERATE
      } 
      else {
         air_status = 2; // BAD
      }

      // ---- Control devices (auto mode) ----
      if(air_status == 0) {
         LED_GREEN=1; LED_YELLOW=0; LED_RED=0;
         FAN=0; fan_status=0; 
         BUZZER=0; buzzer_status=0;
      } 
      else if(air_status == 1) {
         LED_GREEN=0; LED_YELLOW=1; LED_RED=0;
         FAN=1; fan_status=1;  // Turn fan ON for moderate air
         BUZZER=0; buzzer_status=0;
      } 
      else {  
         LED_GREEN=0; LED_YELLOW=0; LED_RED=1;
         FAN=1; fan_status=1; 
         BUZZER=1; buzzer_status=1;
         servo_angle = 90;   // force open window
      }

      // ---- Manual Fan Override (active LOW) ----
      if(!SWITCH1) {
         FAN = 1;     
         fan_status = 1;
      } else {
         // Only revert to auto mode if not in manual override
         if(air_status == 0) {
            FAN = 0;
            fan_status = 0;
         }
      }

      // ---- LCD Displays ----
      // Update servo position once per main loop iteration
      servo_set_angle(servo_angle);
      
      // 1. MQ135 Raw + PPM
      lcd_putc("\fMQ135 : ");
      printf(lcd_putc, "%lu", mq135);
      lcd_gotoxy(1,2);
      printf(lcd_putc, "PPM   : %.2f", mq_ppm);
      delay_ms(1000);

      // 2. PM2.5
      lcd_putc("\fPM2.5 : ");
      printf(lcd_putc, "%lu", pm25);
      lcd_gotoxy(1,2);
      printf(lcd_putc, "VOLT  : %.2f", (pm25*5.0)/1023.0);
      delay_ms(1000);

      // 3. DHT11 Temp/Hum
      printf(lcd_putc, "\fTEMP : %u.%u", T_int, T_dec);
      lcd_putc(0xDF);   // degree symbol
      lcd_putc('C');
      lcd_gotoxy(1,2);
      printf(lcd_putc, "HUMI : %u.%u%%", RH_int, RH_dec);
      delay_ms(1000);

      // 4. Air Quality status
      lcd_putc("\fAir Status :");
      lcd_gotoxy(1,2);
      if(air_status==0)
         lcd_putc("   GOOD   ");
      else if(air_status==1)
         lcd_putc(" MODERATE ");
      else
         lcd_putc("   BAD!!  ");
      delay_ms(1000);

      // 5. Fan + Servo + Buzzer status
      lcd_putc("\fFAN : ");
      lcd_putc(fan_status ? "ON " : "OFF");
      lcd_gotoxy(9,1);
      lcd_putc("BZ:");
      lcd_putc(buzzer_status ? "ON " : "OFF");
      
      lcd_gotoxy(1,2);
      printf(lcd_putc, "SERVO:%u%c ", servo_angle, 0xDF);
      delay_ms(1000);
   }
}

// ------------------- Improved DHT11 Functions -------------------
short dht11_read_data(unsigned int8 *data) {
   unsigned int8 i;
   dht11_start();
   if(!dht11_check_response())
      return 0;
   
   for(i=0; i<5; i++) {
      data[i] = dht11_read_byte();
   }
   
   // Checksum verification
   if(data[4] == ((data[0] + data[1] + data[2] + data[3]) & 0xFF))
      return 1;
   else
      return 0;
}

void dht11_start() {
   output_float(DHT11_PIN);  // Ensure high impedance
   output_low(DHT11_PIN);
   delay_ms(18);            // 18ms low (spec: 18-30ms)
   output_high(DHT11_PIN);
   delay_us(30);            // 30us high
   input(DHT11_PIN);        // Set as input
}

int1 dht11_check_response() {
   delay_us(40);
   if(input(DHT11_PIN)) return 0;  // Should be low
   
   delay_us(80);
   if(!input(DHT11_PIN)) return 0; // Should be high
   
   return 1;
}

unsigned int8 dht11_read_byte() {
   unsigned int8 i, data = 0;
   
   for(i=0; i<8; i++) {
      data <<= 1;
      while(!input(DHT11_PIN));  // Wait for high
      delay_us(30);              // Wait 30us
      
      if(input(DHT11_PIN)) {
         data |= 1;
         while(input(DHT11_PIN)); // Wait for low
      }
   }
   return data;
}
